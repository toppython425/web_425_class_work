# echo-server.py

import socket

HOST = "127.0.0.1"  # Standard loopback interface address (localhost)
PORT = 65432  # Port to listen on (non-privileged ports are > 1023)

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    """С помощью socket.socket() создаётся объект сокета, 
    которым поддерживается тип контекстного менеджера, 
    который используется в операторе with. Вызывать s.close() не нужно:
    Передаваемые в socket() аргументы — это константы, 
    используемые для указания семейства адресов и типа сокетов. 
    AF_INET — это семейство интернет-адресов для IPv4. SOCK_STREAM — это тип сокета для TCP и протокол, 
    который будет использоваться для передачи сообщений в сети."""
    s.bind((HOST, PORT))
    """Метод .bind() применяется для привязки сокета к конкретному сетевому интерфейсу и номеру порта:

    host может быть именем хоста, IP-адресом или пустой строкой. 
    Если используется IP-адрес, то host должен быть строкой адреса формата IPv4. 
    IP-адрес 127.0.0.1 — это стандартный IPv4-адрес для интерфейса «внутренней петли», 
    когда к серверу подключаются только процессы в хосте. 
    Если передавать пустую строку, подключения на сервере принимаются во всех доступных интерфейсах IPv4.

    port — это номер TCP-порта для приёма подключений от клиентов. 
    Это должно быть целое число от 1 до 65535(0 резервируется). 
    В некоторых системах, если номер порта меньше 1024, могут потребоваться привилегии суперпользователя.

    Относительно использования имён хостов с .bind() есть замечание:
    «Если в хостовой части адреса сокета IPv4/v6 использовать имя хоста, 
    программа может стать непредсказуемой: Python использует первый возвращаемый из разрешения DNS адрес. 
    Адрес сокета будет разрешён в фактический адрес IPv4/v6 по-разному, 
    в зависимости от результатов из DNS-разрешения и/или конфигурации хоста. 
    Чтобы поведение было предсказыемым, в хостовой части используйте числовой адрес»

    На текущем этапе достаточно понять, что при использовании имени хоста можно увидеть разные результаты 
    в зависимости от того, чтó возвращается в процессе разрешения имён. 
    Это может быть что угодно: при первом запуске приложения можно получить 10.1.2.3, 
    а в следующий раз получится 192.168.0.1. Дальше может быть 172.16.7.8 и т. д."""

    s.listen()
    """Подключения на сервере принимаются благодаря .listen(), а сам сервер становится «прослушиваемым» сокетом:
    У метода .listen() есть параметр backlog. Он указывает число непринятых подключений, 
    которые система разрешит до отклонения новых подключений. С версии Python 3.5 он необязателен. Если его нет, 
    выбирается значение backlog по умолчанию.
    А если на сервере получается много одновременных запросов на подключение, 
    значение backlog можно увеличить через установку максимальной длины очереди для отложенных подключений. 
    Это предельное значение зависит от системы."""
    conn, addr = s.accept()
    """Методом .accept() выполнение блокируется, и ожидается входящее подключение. 
    При подключении клиента возвращается новый объект сокета, 
    который представляет собой подключение и кортеж с адресом клиента. 
    В кортеже содержится (host, port) — для подключений IPv4 или (host, port, flowinfo, scopeid) — для IPv6."""

    # Итак, теперь у вас есть новый объект сокета из .accept().
    # Это важно потому, что сокет будет использоваться для взаимодействия с клиентом.
    # Он отличается от прослушиваемого, который применяется на сервере для приёма новых подключений:
    with conn:
        print(f"Connected by {addr}")
        while True:
            data = conn.recv(1024)
            if not data:
                break
            conn.sendall(data)

    """После того как в .accept() клиенту предоставляется объект сокета conn, 
    для перебора блокирующих вызовов в conn.recv() используется бесконечный цикл while. 
    Так любые отправляемые от клиента данные считываются и передаются обратно с помощью conn.sendall().

    Если в conn.recv() возвращается пустой объект bytes и b'', значит, 
    в клиенте подключение закрыто и цикл завершён. 
    Чтобы автоматически закрыть сокет в конце блока, с conn применяется оператор with."""
